# -*- coding: utf-8 -*-
"""Untitled14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wwsmGntEp1u5RHye8-InmR6Tj7AIDnug
"""



import pandas as pd
import random

# Feature options
banks = ["HDFC", "ICICI", "SBI"]
rails = ["IMPS", "NEFT", "UPI"]
zones = ["West_Mumbai", "East_Mumbai", "North_Mumbai", "South_Mumbai"]
days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

# Function to generate realistic system health
def generate_system_health():
    bank_uptime = round(random.uniform(0.85, 0.99), 2)
    failure_rate = round(random.uniform(0.0, 0.15), 2)
    network_stability = round(random.uniform(0.80, 1.0), 2)
    maintenance_factor = round(random.choice([1.0, 0.7]), 2)
    system_health = (
        0.4 * bank_uptime +
        0.3 * (1 - failure_rate) +
        0.2 * network_stability +
        0.1 * maintenance_factor
    )
    return round(system_health, 2)

# Generate synthetic dataset
rows = []
for _ in range(100):
    bank = random.choice(banks)
    rail = random.choice(rails)
    zone = random.choice(zones)
    amount = random.randint(1000, 25000)
    hour = random.randint(0, 23)
    day = random.choice(days)
    hist_success = round(random.uniform(0.80, 0.99), 2)
    cost = round(random.uniform(1.0, 5.0), 2)
    health = generate_system_health()

    # Transaction success probability based on historical success and system health
    prob_success = (hist_success + health) / 2
    success = 1 if random.random() < prob_success else 0

    rows.append([
        bank, rail, zone, amount, hour, day, hist_success, cost, health, success
    ])

# Create DataFrame and save CSV
df = pd.DataFrame(rows, columns=[
    "bank_code", "payment_rail", "vendor_zone", "transaction_amount",
    "hour_of_day", "day_of_week", "historical_success_rate",
    "cost_per_transaction", "system_health", "transaction_success"
])

df.to_csv("transaction_history.csv", index=False)
print("✅ Generated transaction_history.csv with 100 rows (realistic system_health)")

df.head()

import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
import pickle

# ---------------------------
# Load synthetic CSV
# ---------------------------
df = pd.read_csv("transaction_history.csv")

# Features and target
X = df.drop("transaction_success", axis=1)
y = df["transaction_success"]

# Categorical and numerical features
categorical_cols = ["bank_code", "payment_rail", "vendor_zone", "day_of_week"]
numerical_cols = ["transaction_amount", "hour_of_day", "historical_success_rate", "cost_per_transaction", "system_health"]

# Preprocessing: One-hot encode categorical features
preprocessor = ColumnTransformer([
    ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_cols)
], remainder='passthrough')

# Random Forest pipeline
rf_pipeline = Pipeline([
    ('preprocess', preprocessor),
    ('rf', RandomForestClassifier(n_estimators=200, max_depth=10, random_state=42))
])

# Train the model
rf_pipeline.fit(X, y)
print("✅ Random Forest model trained")

# Save the model for later use
with open("rf_confidence_scorer.pkl", "wb") as f:
    pickle.dump(rf_pipeline, f)
print("✅ Model saved as rf_confidence_scorer.pkl")

# ---------------------------
# Hybrid Scorer
# ---------------------------
def fallback_score(transaction_features: dict) -> float:
    """Simple heuristic fallback"""
    hist_success = transaction_features.get("historical_success_rate", 0.5)
    health = transaction_features.get("system_health", 0.5)
    return round((hist_success + health) / 2, 2)

def ml_score(transaction_features: dict) -> float:
    try:
        # Load trained pipeline
        with open("rf_confidence_scorer.pkl", "rb") as f:
            model = pickle.load(f)
        df_input = pd.DataFrame([transaction_features])
        prob = model.predict_proba(df_input)[0][1]  # probability of success
        return float(prob)
    except Exception as e:
        print(f"ML prediction failed: {e}")
        return 0.0

def llm_score(transaction_features: dict) -> float:
    """Placeholder LLM (could be Gemini/OpenAI)"""
    print("LLM not configured. Using fallback heuristic")
    return fallback_score(transaction_features)

def hybrid_confidence_scorer(transaction_features: dict) -> float:
    ml_conf = ml_score(transaction_features)
    if ml_conf >= 0.8:
        print(f"✅ ML confident: {ml_conf:.2f}")
        return ml_conf
    else:
        print(f"⚠️ ML uncertain ({ml_conf:.2f}), using LLM/fallback...")
        return llm_score(transaction_features)

# ---------------------------
# Example Usage
# ---------------------------
if __name__ == "__main__":
    test_transaction = {
        "bank_code": "HDFC",
        "payment_rail": "NEFT",
        "vendor_zone": "East_Mumbai",
        "transaction_amount": 5000,
        "hour_of_day": 10,
        "day_of_week": "Monday",
        "historical_success_rate": 0.95,
        "cost_per_transaction": 2.5,
        "system_health": 0.98
    }

    score = hybrid_confidence_scorer(test_transaction)
    print(f"Hybrid Confidence Score: {score:.2f}")

# Commented out IPython magic to ensure Python compatibility.
# %pip install --upgrade lightgbm